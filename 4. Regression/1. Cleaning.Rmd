# Limpieza

## Imports necesarios

```{r}
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("tidyr")
```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
```

## 1. Tratamiento de valores atípicos

### 1.1. Detección de outliers

Calcular el **rango intercuartílico** (**IQR**) y considerar valores que estén fuera de 1.5 veces el IQR como posibles outliers.

```{r}
detectar_atipicos_iqr <- function(df, columna) {
  # Seleccionar la columna de interés
  columna_interes <- df[[columna]]

  # Calcular el rango intercuartílico (IQR)
  Q1 <- quantile(columna_interes, 0.25, na.rm = TRUE)
  Q3 <- quantile(columna_interes, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1

  # Definir los umbrales para identificar valores atípicos
  umbral_superior <- Q3 + 1.5 * IQR
  umbral_inferior <- Q1 - 1.5 * IQR

  # Identificar valores atípicos
  indices_atipicos <- which(columna_interes > umbral_superior | columna_interes < umbral_inferior)

  valores_atipicos <- df[indices_atipicos, ]

  # Devolver el resultado
  resultado <- list(dataframe = valores_atipicos, indices_atipicos = indices_atipicos)
  return(resultado)
}

```

El **método de Z-Score** calcula cuántas desviaciones estándar un punto de datos está lejos de la media. Los puntos con un Z-Score alto o bajo en valor absoluto se consideran atípicos.

```{r}
detectar_atipicos_z <- function(df, columna) {
  # Seleccionar la columna de interés
  columna_interes <- df[[columna]]

  # Imputar valores nulos con la media de la columna
  columna_interes[is.na(columna_interes)] <- mean(columna_interes, na.rm = TRUE)

  # Calcular el Z-Score
  z_scores <- scale(columna_interes)

  # Establecer un umbral de Z-Score para identificar valores atípicos
  umbral_z_score <- 2  # Se puede ajustar este valor según las necesidades

  # Identificar valores atípicos basados en el Z-Score
  indices_atipicos <- which(abs(z_scores) > umbral_z_score)

  valores_atipicos <- df[indices_atipicos, ]

  # Devolver el resultado
  resultado <- list(dataframe = valores_atipicos, indices_atipicos = indices_atipicos)
  return(resultado)
}
```

### 1.2. Tratamiento de outliers

En esta sección, nos enfocamos en abordar los valores atípicos (outliers) presentes en nuestros datos. Los outliers pueden afectar significativamente el rendimiento de los modelos y distorsionar las conclusiones extraídas de nuestro análisis. Por lo tanto, implementamos diversas estratégias, ya sea reemplazando con la media, mediana, desviación o un valor específico o eliminando la fila entera, para gestionar estos valores inusuales y mejorar la calidad de nuestros datos.

Imputación con la **media** de los valores no atípicos.

```{r}
reemplazar_outliers_con_media_no_atipicos <- function(df, columna, tratamiento = "iqr") {

  df_res <- df

  if (tratamiento == "iqr") {
    atipicos <- detectar_atipicos_iqr(datos, columna)
  } else if (tratamiento == "z") {
    atipicos <- detectar_atipicos_z(datos, columna)
  }

  indices_atipicos <- atipicos$indices_atipicos

  indices_no_atipicos <- setdiff(seq_len(nrow(df_res)), indices_atipicos)

  # Calcular la media de los valores no atípicos
  media_no_atipicos <- mean(datos[[columna]][indices_no_atipicos], na.rm = TRUE)

  # Rellenar valores atípicos con la media de los no atípicos
  df_res[indices_atipicos, columna] <- media_no_atipicos

  return(df_res)
}
```

Imputación con la **mediana** de los valores no atípicos.

```{r}
reemplazar_outliers_con_mediana_no_atipicos <- function(df, columna, tratamiento = "iqr") {

  df_res <- df

  if (tratamiento == "iqr") {
    atipicos <- detectar_atipicos_iqr(datos, columna)
  } else if (tratamiento == "z") {
    atipicos <- detectar_atipicos_z(datos, columna)
  }

  indices_atipicos <- atipicos$indices_atipicos

  indices_no_atipicos <- setdiff(seq_len(nrow(df_res)), indices_atipicos)

  # Calcular la mediana de los valores no atípicos
  mediana_no_atipicos <- median(datos[[columna]][indices_no_atipicos], na.rm = TRUE)

  # Reemplazar valores atípicos con la mediana de los no atípicos
  df_res[indices_atipicos, columna] <- mediana_no_atipicos

  return(df_res)
}
```

Imputación con la **mediana** de los valores no atípicos

```{r}
reemplazar_outliers_con_desviacion <- function(df, columna, tratamiento = "iqr") {

  df_res <- df

  if (tratamiento == "iqr") {
    atipicos <- detectar_atipicos_iqr(datos, columna)
  } else if (tratamiento == "z") {
    atipicos <- detectar_atipicos_z(datos, columna)
  }

  # Obtener los índices de las filas atípicas
  indices_atipicos <- atipicos$indices_atipicos

  # Obtener los índices de las filas no atípicas
  indices_no_atipicos <- setdiff(seq_len(nrow(df_res)), indices_atipicos)

  # Calcular la desviación estándar de los valores no atípicos
  desviacion_no_atipicos <- sd(df_res[[columna]][indices_no_atipicos], na.rm = TRUE)

  # Reemplazar valores atípicos con la desviación estándar de los no atípicos
  df_res[indices_atipicos, columna] <- desviacion_no_atipicos

  return(df_res)
}
```

**Eliminación de filas** que contienen outliers.

```{r}

eliminar_filas_outliers <- function(df, columna, tratamiento = "iqr") {

  df_res <- df

  if (tratamiento == "iqr") {
    atipicos <- detectar_atipicos_iqr(datos, columna)
  } else if (tratamiento == "z") {
    atipicos <- detectar_atipicos_z(datos, columna)
  }

  indices_atipicos <- atipicos$indices_atipicos

  # Eliminar las filas atípicas del DataFrame resultante
  df_res <- df_res[-indices_atipicos, , drop = FALSE]

  return(df_res)
}
```

Imputación con **valor específico**.

```{r}

reemplazar_outliers_con_valor <- function(df, columna, valor_reemplazo, tratamiento = "iqr") {
  
  df_res <- df
  
  if (tratamiento == "iqr") {
    atipicos <- detectar_atipicos_iqr(datos, columna)
  } else if (tratamiento == "z") {
    atipicos <- detectar_atipicos_z(datos, columna)
  }

  indices_atipicos <- atipicos$indices_atipicos
  
  # Reemplazar los valores atípicos con el valor especificado
  df_res[indices_atipicos, columna] <- valor_reemplazo
  
  return(df_res)
}
```

## 2. Tratamiento de valores nulos en variables numéricas

En esta etapa, nos ocupamos de abordar los valores nulos presentes en las columnas numéricas de nuestro conjunto de datos. La presencia de datos faltantes puede afectar la integridad y la validez de nuestros análisis y modelos. Por lo tanto, implementamos estrategias específicas para gestionar estos valores nulos y garantizar la coherencia.

### 2.1. Tratamiento de la columna "Numero de estudiantes"

```{r}

clean_null_students <- function(datos, tratamiento) {
  # Identificar valores nulos en la columna "Número.de.estudiantes"
  valores_nulos_estudiantes <- sum(is.na(datos$Número.de.estudiantes))
  if (valores_nulos_estudiantes > 0) {
    # Seleccionar los valores no nulos para calcular desviación típica
    valores_no_nulos <- datos$Número.de.estudiantes[!is.na(datos$Número.de.estudiantes)]
    # Tratar valores nulos según el parámetro proporcionado
    if (tratamiento == 1) {
      #Media
      media_relleno <- mean(datos$Número.de.estudiantes, na.rm = TRUE)
      datos$Número.de.estudiantes <- ifelse(is.na(datos$Número.de.estudiantes), media_relleno, datos$Número.de.estudiantes)
      nombre_archivo <- "./data/CleanData/datos_media.csv"
    } else if (tratamiento == 0) {
      #Mediana
      mediana_relleno <- median(datos$Número.de.estudiantes, na.rm = TRUE)
      datos$Número.de.estudiantes <- ifelse(is.na(datos$Número.de.estudiantes), mediana_relleno, datos$Número.de.estudiantes)
      nombre_archivo <- "./data/CleanData/datos_mediana.csv"
    } else if (tratamiento == 2) {
      #Desviación típica
      desviacion_tipica_relleno <- sd(valores_no_nulos)
      datos$Número.de.estudiantes <- ifelse(is.na(datos$Número.de.estudiantes), desviacion_tipica_relleno, datos$Número.de.estudiantes)
      nombre_archivo <- "./data/CleanData/datos_desviacion_tipica.csv"
    } else {
      stop("El valor del parámetro 'tratamiento' debe ser 0, 1 o 2.")
    }
  } else {
    cat("No hay valores nulos en la columna 'Número.de.estudiantes'. No se requiere tratamiento.\n")
  }
  # Devolver los datos tratados
  return(datos)
}
```

### 2.2. Tratamiento de la columna "Nota media"

```{r}
clean_null_grade_average <- function(datos, tratamiento) {
  # Identificar valores nulos en la columna "Nota.media"
  valores_nulos_estudiantes <- sum(is.na(datos$Nota.media))
  if (valores_nulos_estudiantes > 0) {
    # Seleccionar los valores no nulos para calcular desviación típica
    valores_no_nulos <- datos$Nota.media[!is.na(datos$Nota.media)]
    # Tratar valores nulos según el parámetro proporcionado
    if (tratamiento == 1) {
      #Media
      media_relleno <- mean(datos$Nota.media, na.rm = TRUE)
      datos$Nota.media <- ifelse(is.na(datos$Nota.media), media_relleno, datos$Nota.media)
      nombre_archivo <- "./data/CleanData/datos_media.csv"
    } else if (tratamiento == 0) {
      #Mediana
      mediana_relleno <- median(datos$Nota.media, na.rm = TRUE)
      datos$Nota.media <- ifelse(is.na(datos$Nota.media), mediana_relleno, datos$Nota.media)
      nombre_archivo <- "./data/CleanData/datos_mediana.csv"
    } else if (tratamiento == 2) {
      #Desviación típica
      desviacion_tipica_relleno <- sd(valores_no_nulos)
      datos$Nota.media <- ifelse(is.na(datos$Nota.media), desviacion_tipica_relleno, datos$Nota.media)
      nombre_archivo <- "./data/CleanData/datos_desviacion_tipica.csv"
    } else {
      stop("El valor del parámetro 'tratamiento' debe ser 0, 1 o 2.")
    }
  } else {
    cat("No hay valores nulos en la columna 'Nota.media'. No se requiere tratamiento.\n")
  }
  # Devolver los datos tratados
  return(datos)
}
```

## 3. Consistencia de datos

En esta fase, nos centramos en garantizar la coherencia y la integridad de los datos, especialmente en lo que respecta al número de estudiantes y las columnas categóricas de nuestro conjunto de datos. Buscamos corregir desviaciones, como números que no sean enteros o valores que no son los correspondientes a una columna categórica.

### 3.1. Tratamiento de la columna 'Numero de estudiantes'

Aseguramos que los valores en la columna de número de estudiantes sean enteros, ya que el número de estudiantes debe ser una cantidad discreta. Con estas funciones, hay varias opciones a elegir para solucionar el problema.

```{r}
redondeo_estandar <- function(df, columna) {
    df[[columna]] <- round(df[[columna]])
    return(df)
}

redondeo_arriba <- function(df, columna) {
    df[[columna]] <- ceiling(df[[columna]])
    return(df)
}

redondeo_abajo <- function(df, columna) {
    df[[columna]] <- floor(df[[columna]])
    return(df)
}

sustituir_constante <- function(df, columna, constante = 20) {
    df[[columna]][is.na(df[[columna]])] <- constante
        return(df)
}

rellenar_media <- function(df, columna) {
    media <- mean(df[[columna]], na.rm = TRUE)
    df[[columna]][is.na(df[[columna]])] <- as.integer(round(media))
    df[[columna]] <- as.integer(df[[columna]])
    return(df)
}

rellenar_mediana <- function(df, columna) {
    mediana <- median(df[[columna]], na.rm = TRUE)
    df[[columna]][is.na(df[[columna]])] <- as.integer(round(mediana))
    df[[columna]] <- as.integer(df[[columna]])
    return(df)
}

```

### 3.2. Tratamiento de las columnas con valores categóricos

Dependiendo de la opción que se elija, se trataran aquellos valores atipicos sustituyendo por una constante o con el valor mas frecuente de la columna.

```{r}

rellenar_valores_atipicos <- function(df, columnas, valores_validos, metodo, constante = NULL) {
  for (columna in columnas) {
    valores_validos_columna <- valores_validos[[columna]]
    valores_invalidos <- df[[columna]][!(df[[columna]] %in% valores_validos_columna)]
    
    if (metodo == "constante") {
      if (!is.null(constante)) {
        if (length(valores_invalidos) > 0) {
          df[[columna]][!(df[[columna]] %in% valores_validos_columna)] <- constante
        }
      } else {
        stop("Por favor, proporciona un valor para la constante.")
      }
    } else if (metodo == "mas_probable") {
      if (length(valores_invalidos) > 0) {
        valor_mas_probable <- names(which.max(table(df[[columna]][df[[columna]] %in% valores_validos_columna])))
        df[[columna]][!(df[[columna]] %in% valores_validos_columna)] <- valor_mas_probable
      }
    } else {
      stop("El método proporcionado no es válido. Usa 'constante' o 'mas_probable'.")
    }
  }
  return(df)
}



columnas <- c("Sexo", "Universidad", "Admisión", "Zona.de.nacionalidad", "Rama.de.enseñanza", "Comunidad.Autónoma")
valores_validos <- list(
    Sexo = c("Hombres", "Mujeres"),
    Admisión = c("PAU", "FP"),
    Zona.de.nacionalidad = c("España", "Unión Europea", "Resto de Europa", "EEUU y Canadá", "América Latina y Caribe", "Norte de África", "Resto de África", "Asia y Oceanía"),
    Rama.de.enseñanza = c("Artes y Humanidades", "Ciencias", "Ciencias de la Salud", "Ciencias Sociales y Jurídicas", "Ingeniería y Arquitectura"),
    Comunidad.Autónoma = c("Andalucía", "Aragón", "Asturias", "Baleares", "Canarias", "Cantabria", "Castilla y León", "Castilla-La Mancha", "Cataluña", "Ceuta y Melilla", "Comunidad Valenciana", "Extremadura", "Galicia", "La Rioja", "Madrid", "Murcia", "Navarra", "País Vasco"),
    Universidad = c("Cádiz", "Córdoba", "Granada", "Huelva", "Jaén", "Málaga", "Pablo de Olavide", "Sevilla", "Zaragoza", "Oviedo", "Cantabria", "Castilla-La Mancha", "Burgos", "León", "Salamanca", "Valladolid", "Autónoma de Barcelona", "Barcelona", "Girona", "Lleida", "Politécnica de Catalunya", "Pompeu Fabra", "Rovira i Virgili", "Extremadura", "A Coruña", "Santiago de Compostela", "Vigo", "Illes Balears (Les)", "La Laguna", "Las Palmas de Gran Canaria", "La Rioja", "Alcalá", "Autónoma de Madrid", "Carlos III de Madrid", "Complutense de Madrid", "Politécnica de Madrid", "Rey Juan Carlos", "Murcia", "Politécnica de Cartagena", "Pública de Navarra", "País Vasco/Euskal Herriko Unibertsitatea", "Alicante", "Jaume I de Castellón", "Miguel Hernández de Elche", "Politècnica de València", "València (Estudi General)")
)

```

## 4. Aplicación del proceso de limpieza

Lectura de los datos a partir del dataset con ruido.

```{r}
datos <- read.csv('../2. Add-noise/dataset_ruido.csv')
```

### 4.1. Función para llevar a cabo los distintos tratamientos definidos

```{r}

tratar_datos_combinado <- function(datos, modo_outliers, modo_null_students, modo_null_grade_avg, modo_outliers_grade,modo_outliers_grade_relleno, constante = Desconocido) {
  # Tratamiento de outliers
  df_outliers <- switch(modo_outliers,
                        "media_iqr" = reemplazar_outliers_con_media_no_atipicos(datos, "Nota.media", "iqr"),
                        "mediana_iqr" = reemplazar_outliers_con_mediana_no_atipicos(datos, "Nota.media", "iqr"),
                        "desviacion_iqr" = reemplazar_outliers_con_desviacion(datos, "Nota.media", "iqr"),
                        "remplazo_iqr" = reemplazar_outliers_con_valor(datos, "Nota.media", 10, "iqr"),
                        "eliminado_iqr" = eliminar_filas_outliers(datos, "Nota.media", "iqr"),
                        "media_z" = reemplazar_outliers_con_media_no_atipicos(datos, "Nota.media", "z"),
                        "desviacion_z" = reemplazar_outliers_con_desviacion(datos, "Nota.media", "z"),
                        "mediana_z" = reemplazar_outliers_con_mediana_no_atipicos(datos, "Nota.media", "z"),
                        "remplazo_z" = reemplazar_outliers_con_valor(datos, "Nota.media", 10, "z"),
                        "eliminado_z" = eliminar_filas_outliers(datos, "Nota.media", "z")
  )

  # Tratamiento de valores nulos en estudiantes
  df_null_students <- switch(modo_null_students,
                              "students_mediana" = clean_null_students(df_outliers, 0),
                              "students_media" = clean_null_students(df_outliers, 1),
                              "students_desviacion" = clean_null_students(df_outliers, 2)
  )

  # Tratamiento de valores nulos en nota media
  df_null_grade_avg <- switch(modo_null_grade_avg,
                               "grade_avg_mediana" = clean_null_grade_average(df_null_students, 0),
                               "grade_avg_media" = clean_null_grade_average(df_null_students, 1),
                               "grade_avg_desviacion" = clean_null_grade_average(df_null_students, 2)
  )

  # Tratamiento de valores atípicos en número de estudiantes
  df_outliers_grade <- df_null_grade_avg
  df_outliers_grade[df_outliers_grade < 0] <- 0

  df_atipicos <- switch(modo_outliers_grade,
                        "red_estandar" = redondeo_estandar(df_outliers_grade, "Número.de.estudiantes"),
                        "red_arriba" = redondeo_arriba(df_outliers_grade, "Número.de.estudiantes"),
                        "red_abajo" = redondeo_abajo(df_outliers_grade, "Número.de.estudiantes"),
                        "sustituir_constante" = sustituir_constante(df_outliers_grade, "Número.de.estudiantes", 20),
                        "rellenar_media" = rellenar_media(df_outliers_grade, "Número.de.estudiantes"),
                        "rellenar_mediana" = rellenar_mediana(df_outliers_grade, "Número.de.estudiantes")
  )

  # Rellenar valores atípicos en el dataframe final
  df_final <- switch(modo_outliers_grade_relleno,
                     "rellenar_mas_probable" = rellenar_valores_atipicos(df_atipicos, columnas, valores_validos, "mas_probable"),
                     "rellenar_constante" = rellenar_valores_atipicos(df_atipicos, columnas, valores_validos, "constante", constante)
  )

  return(df_final)
}

```

### 4.2. Uso de la función global definida

```{r}

df_final <- tratar_datos_combinado(datos, "media_iqr", "students_mediana", "grade_avg_mediana", "red_estandar", "rellenar_mas_probable")
```

## 5. Exportación de los datos tratados a un fichero CSV

```{r}

nombre_archivo <- "../data/CleanData/datos_tratados.csv"
write.csv(df_final, file = nombre_archivo, row.names = FALSE)
cat("Datos tratados y exportados a", nombre_archivo, "\n")
```
